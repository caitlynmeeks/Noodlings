<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>noodleMUSH Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        body {
            margin: 0;
            padding: 10px;
            background-color: #000000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #terminal-container {
            width: 100%;
            height: 100vh;
        }
        #terminal {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal-container">
        <div id="terminal"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>

    <script>
        // Create terminal with WYSE amber theme - BIG and FULL WIDTH
        const term = new Terminal({
            cursorBlink: true,
            cursorStyle: 'block',
            fontSize: 24,  // Bigger!
            fontFamily: '"Courier New", monospace',
            theme: {
                background: '#000000',
                foreground: '#ffb000',
                cursor: '#ffd700',
                cursorAccent: '#000000',
                selectionBackground: '#ffb000',
                selectionForeground: '#000000',
                brightYellow: '#ffd700',
                brightWhite: '#ffd700'
            },
            allowProposedApi: true,
            cols: 120,  // Wide terminal
            rows: 40    // Tall terminal
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        window.addEventListener('resize', () => fitAddon.fit());

        // Connect directly to noodleMUSH WebSocket
        const ws = new WebSocket('ws://localhost:8765');
        let inputBuffer = '';
        let authenticated = false;
        let loginState = 'none'; // 'none', 'need_username', 'need_password', 'authenticated'

        ws.onopen = () => {
            term.writeln('\x1b[1;33mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\x1b[0m');
            term.writeln('\x1b[1;33mâ•‘\x1b[0m  \x1b[1;37mnoodleMUSH\x1b[0m - Noodlings Multi-User Shared Hallucination  \x1b[1;33mâ•‘\x1b[0m');
            term.writeln('\x1b[1;33mâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\x1b[0m');
            term.writeln('');
            term.writeln('\x1b[33mConnected to server!\x1b[0m');
            term.writeln('');

            // Auto-login
            const savedUser = localStorage.getItem('noodlemush_username');
            const savedPass = localStorage.getItem('noodlemush_password');

            if (savedUser && savedPass) {
                term.writeln('\x1b[2mAttempting auto-login...\x1b[0m');
                loginState = 'authenticating';
                ws.send(JSON.stringify({
                    type: 'login',
                    username: savedUser,
                    password: savedPass
                }));
            } else {
                loginState = 'need_username';
                term.write('\x1b[33mUsername:\x1b[0m ');
            }
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log('Received from server:', data);

            if (data.type === 'message') {
                const sender = data.sender || 'Unknown';
                const content = data.content || '';
                const isThought = data.is_thought || false;

                if (isThought) {
                    term.writeln(`\x1b[2mðŸ§  ${sender} privately thinks: ${content}\x1b[0m`);
                } else {
                    term.writeln(`\x1b[1;33m${sender}\x1b[0m: ${content}`);
                }
                term.write('\x1b[33m>\x1b[0m ');

            } else if (data.type === 'system') {
                const sysMsg = data.content || '';
                term.writeln(`\x1b[2m${sysMsg}\x1b[0m`);
                if (!authenticated && sysMsg.includes('Welcome')) {
                    authenticated = true;
                    term.write('\x1b[33m>\x1b[0m ');
                }

            } else if (data.type === 'login_response') {
                if (data.success) {
                    authenticated = true;
                    loginState = 'authenticated';
                    localStorage.setItem('noodlemush_username', username || data.user_id);
                    term.writeln('');
                    term.writeln(`\x1b[1;32mâœ“ ${data.message || 'Logged in!'}\x1b[0m`);
                    term.writeln('');
                    term.write('\x1b[33m>\x1b[0m ');
                } else {
                    term.writeln(`\x1b[31mâœ— ${data.message || 'Login failed'}\x1b[0m`);
                    loginState = 'need_username';
                    term.write('\x1b[33mUsername:\x1b[0m ');
                }

            } else if (data.type === 'error') {
                const errorMsg = data.content || data.message || 'Unknown error';
                term.writeln(`\x1b[31mâœ— ${errorMsg}\x1b[0m`);

                // If login failed, ask again
                if (loginState === 'authenticating') {
                    loginState = 'need_username';
                    term.write('\x1b[33mUsername:\x1b[0m ');
                }

            } else if (data.type === 'output') {
                // Command output from server
                const output = data.text || data.content || '';
                if (output) {
                    term.writeln(output);
                }
                term.write('\x1b[33m>\x1b[0m ');

            } else {
                // Unknown message type - log it
                console.log('Unknown message type:', data.type, data);

                // If it has content, try to display it
                if (data.content || data.text) {
                    term.writeln(data.content || data.text);
                }
                term.write('\x1b[33m>\x1b[0m ');
            }
        };

        ws.onerror = () => {
            term.writeln('\x1b[31mConnection error!\x1b[0m');
        };

        ws.onclose = () => {
            term.writeln('\x1b[33mConnection closed\x1b[0m');
        };

        // Handle keyboard input
        let username = '';

        term.onData((data) => {
            if (data === '\r') {  // Enter key
                term.writeln('');

                if (loginState === 'need_username') {
                    username = inputBuffer.trim();
                    inputBuffer = '';
                    loginState = 'need_password';
                    term.write('\x1b[33mPassword:\x1b[0m ');

                } else if (loginState === 'need_password') {
                    const password = inputBuffer.trim();
                    inputBuffer = '';
                    loginState = 'authenticating';

                    ws.send(JSON.stringify({
                        type: 'login',
                        username: username,
                        password: password
                    }));

                } else if (authenticated && inputBuffer.trim()) {
                    const cmd = inputBuffer.trim();
                    console.log('Sending command:', cmd);
                    ws.send(JSON.stringify({
                        type: 'command',
                        command: cmd  // Server expects 'command' not 'content'!
                    }));
                    inputBuffer = '';
                }

            } else if (data === '\x7f') {  // Backspace
                if (inputBuffer.length > 0) {
                    inputBuffer = inputBuffer.slice(0, -1);
                    term.write('\b \b');
                }
            } else if (data === '\x03') {  // Ctrl+C
                term.writeln('^C');
                inputBuffer = '';
                if (authenticated) {
                    term.write('\x1b[33m>\x1b[0m ');
                }
            } else {
                inputBuffer += data;
                // Hide password input
                if (loginState === 'need_password') {
                    term.write('*');
                } else {
                    term.write(data);
                }
            }
        });

        term.focus();
    </script>
</body>
</html>
